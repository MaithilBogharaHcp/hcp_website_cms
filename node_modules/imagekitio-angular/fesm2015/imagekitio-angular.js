import * as i0 from '@angular/core';
import { Injectable, Component, Input, EventEmitter, Output, NgModule } from '@angular/core';
import ImageKit from 'imagekit-javascript';
import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';

const SDK_VERSION = '5.0.0';
class ImageKitConfiguration {
}
class ImagekitService {
    constructor(configuration) {
        this.configuration = configuration;
        (configuration.sdkVersion = `angular-${SDK_VERSION}`),
            (this._ikInstance = new ImageKit(this.configuration));
    }
    get ikInstance() {
        return this._ikInstance;
    }
    getUrl(config) {
        const url = this._ikInstance.url(config);
        return url;
    }
}
ImagekitService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ImagekitService, deps: [{ token: ImageKitConfiguration }], target: i0.ɵɵFactoryTarget.Injectable });
ImagekitService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ImagekitService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ImagekitService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: ImageKitConfiguration }]; } });

class IkImageComponent {
    constructor(el, imagekit) {
        this.el = el;
        this.imagekit = imagekit;
        this.transformation = [];
        this.url = '';
        this.lqipUrl = '';
        this.onImageLoaded = (event) => {
            const { loading, lqipUrl, url } = this;
            if (loading !== 'lazy' && event.srcElement.src === lqipUrl) {
                this.loadImage(this, url);
            }
        };
    }
    ngOnInit() {
        const options = this.src ? { src: this.src } : { path: this.path };
        options.urlEndpoint = this.urlEndpoint ? this.urlEndpoint : this.imagekit._ikInstance.options.urlEndpoint;
        options.transformation = this.transformation;
        options.transformationPosition = this.transformationPosition;
        options.queryParameters = this.queryParameters;
        options.lqip = this.lqip;
        this.setUrl(options);
    }
    ngOnChanges() {
        this.ngOnInit();
        this.ngAfterViewInit();
    }
    ngAfterViewInit() {
        if (this.loading == 'lazy') {
            const that = this;
            if (this.lqipUrl) {
                // If given LQIP, use that first
                this.loadImage(this, this.lqipUrl);
            }
            const imageObserver = new IntersectionObserver((entry, observer) => {
                // Always load the original image when intersecting
                that.handleIntersectionObserver(entry, observer, that.loadImage, that, that.url);
            });
            imageObserver.observe(this.el.nativeElement);
        }
        else {
            // If given LQIP, use that first
            this.loadImage(this, this.lqipUrl ? this.lqipUrl : this.url);
        }
    }
    handleIntersectionObserver(entry, observer, loadImageFunc, context, url) {
        if (entry[0] && entry[0].isIntersecting) {
            let image = entry[0].target;
            loadImageFunc(context, url);
            observer.unobserve(image);
        }
    }
    setUrl(options) {
        const config = this.getConfigObject(options);
        this.url = this.imagekit.getUrl(config);
        if (options.lqip && options.lqip.active === true) {
            this.lqipUrl = this.constructLqipUrl(options, options.lqip);
        }
    }
    constructLqipUrl(options, lqip) {
        if (lqip && lqip.active) {
            var quality = Math.round(lqip.quality || lqip.threshold || 20);
            var blur = Math.round(lqip.blur || 6);
            var newTransformation = options.transformation ? [...options.transformation] : [];
            if (lqip.raw && typeof lqip.raw === "string" && lqip.raw.trim() != "") {
                newTransformation.push({
                    raw: lqip.raw.trim()
                });
            }
            else {
                newTransformation.push({
                    quality: String(quality),
                    blur: String(blur),
                });
            }
            return this.imagekit.ikInstance.url(Object.assign(Object.assign({}, options), { transformation: newTransformation }));
        }
    }
    getConfigObject(options) {
        const config = {
            transformation: options.transformation
        };
        if (options.urlEndpoint) {
            config['urlEndpoint'] = options.urlEndpoint;
        }
        else {
            throw new Error('Missing urlEndpoint initialization!');
        }
        if (options.queryParameters) {
            config['queryParameters'] = options.queryParameters;
        }
        if (options.src) {
            config['src'] = options.src;
            config['transformationPosition'] = 'query';
        }
        else if (options.path) {
            config['path'] = options.path;
            if (options.transformationPosition) {
                config['transformationPosition'] = options.transformationPosition;
            }
        }
        else {
            throw new Error('Missing src / path during initialization!');
        }
        return config;
    }
    loadImage(context, url) {
        const nativeElement = context.el.nativeElement;
        const attributes = nativeElement.attributes;
        const attrsToSet = context.namedNodeMapToObject(attributes);
        attrsToSet['src'] = url;
        const image = nativeElement.children[0];
        context.setElementAttributes(image, attrsToSet);
    }
    namedNodeMapToObject(source) {
        let target = {};
        Object.keys(source).forEach(index => {
            const name = source[index].name;
            const value = source[index].value;
            target[name] = value;
        });
        return target;
    }
    ;
    setElementAttributes(element, attributesLiteral) {
        Object.keys(attributesLiteral).filter(attrName => attrName !== 'loading').forEach(attrName => {
            element.setAttribute(attrName, attributesLiteral[attrName]);
        });
    }
}
IkImageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IkImageComponent, deps: [{ token: i0.ElementRef }, { token: ImagekitService }], target: i0.ɵɵFactoryTarget.Component });
IkImageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IkImageComponent, selector: "ik-image", inputs: { src: "src", path: "path", urlEndpoint: "urlEndpoint", transformation: "transformation", transformationPosition: "transformationPosition", queryParameters: "queryParameters", lqip: "lqip", loading: "loading" }, usesOnChanges: true, ngImport: i0, template: `<img src='' (load)="onImageLoaded($event)">`, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IkImageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ik-image',
                    template: `<img src='' (load)="onImageLoaded($event)">`,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: ImagekitService }]; }, propDecorators: { src: [{
                type: Input,
                args: ['src']
            }], path: [{
                type: Input,
                args: ['path']
            }], urlEndpoint: [{
                type: Input,
                args: ['urlEndpoint']
            }], transformation: [{
                type: Input,
                args: ['transformation']
            }], transformationPosition: [{
                type: Input,
                args: ['transformationPosition']
            }], queryParameters: [{
                type: Input,
                args: ['queryParameters']
            }], lqip: [{
                type: Input,
                args: ['lqip']
            }], loading: [{
                type: Input,
                args: ['loading']
            }] } });

class IkVideoComponent {
    constructor(el, imagekit) {
        this.el = el;
        this.imagekit = imagekit;
        this.transformation = [];
        this.url = '';
    }
    ngOnInit() {
        const options = this.src ? { src: this.src } : { path: this.path };
        options.transformation = this.transformation;
        options.transformationPosition = this.transformationPosition;
        options.urlEndpoint = this.urlEndpoint;
        options.queryParameters = this.queryParameters;
        this.setUrl(options);
    }
    ngAfterViewInit() {
        this.loadVideo(this.url);
    }
    loadVideo(url) {
        const nativeElement = this.el.nativeElement;
        const attributes = nativeElement.attributes;
        const attrsToSet = this.namedNodeMapToObject(attributes);
        attrsToSet['src'] = url;
        const video = nativeElement.children[0];
        this.setElementAttributes(video, attrsToSet);
    }
    namedNodeMapToObject(source) {
        let target = {};
        Object.keys(source).forEach(index => {
            const name = source[index].name;
            const value = source[index].value;
            target[name] = value;
        });
        return target;
    }
    ;
    setUrl(options) {
        const config = this.getConfigObject(options);
        this.url = this.imagekit.getUrl(config);
    }
    getConfigObject(options) {
        const config = {
            transformation: options.transformation,
        };
        if (options.urlEndpoint) {
            config['urlEndpoint'] = options.urlEndpoint;
        }
        else {
            throw new Error('Missing urlEndpoint initialization!');
        }
        if (options.queryParameters) {
            config['queryParameters'] = options.queryParameters;
        }
        if (options.src) {
            config['src'] = options.src;
            config['transformationPosition'] = 'query';
        }
        else if (options.path) {
            config['path'] = options.path;
            if (options.transformationPosition) {
                config['transformationPosition'] = options.transformationPosition;
            }
        }
        else {
            throw new Error('Missing src / path during initialization!');
        }
        return config;
    }
    setElementAttributes(element, attributesLiteral) {
        Object.keys(attributesLiteral).forEach(attrName => {
            element.setAttribute(attrName, attributesLiteral[attrName]);
        });
    }
}
IkVideoComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IkVideoComponent, deps: [{ token: i0.ElementRef }, { token: ImagekitService }], target: i0.ɵɵFactoryTarget.Component });
IkVideoComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IkVideoComponent, selector: "ik-video", inputs: { urlEndpoint: "urlEndpoint", path: "path", src: "src", transformation: "transformation", transformationPosition: "transformationPosition", queryParameters: "queryParameters" }, ngImport: i0, template: `<video controls><source src={{src}}>`, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IkVideoComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ik-video',
                    template: `<video controls><source src={{src}}>`,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: ImagekitService }]; }, propDecorators: { urlEndpoint: [{
                type: Input,
                args: ['urlEndpoint']
            }], path: [{
                type: Input,
                args: ['path']
            }], src: [{
                type: Input,
                args: ['src']
            }], transformation: [{
                type: Input,
                args: ['transformation']
            }], transformationPosition: [{
                type: Input,
                args: ['transformationPosition']
            }], queryParameters: [{
                type: Input,
                args: ['queryParameters']
            }] } });

class IkUploadComponent {
    constructor(el, imagekit) {
        this.el = el;
        this.imagekit = imagekit;
        this.onError = new EventEmitter();
        this.onSuccess = new EventEmitter();
        this.fileToUpload = null;
        this.handleAuthResponse = ({ signature, token, expire }, ik, params, options, progressCb) => {
            ik.upload(Object.assign(Object.assign({}, params), { signature, token, expire }), (err, result) => {
                this.handleUploadResponse(err, result, options, progressCb);
            });
        };
    }
    ngAfterViewInit() {
        this.buttonRef && this.buttonRef.addEventListener('click', () => { this.el.nativeElement.children[0].click(); });
    }
    abort() {
        if (this.xhr) {
            this.xhr.abort();
        }
    }
    handleFileInput(e) {
        // Using IK-upload
        const files = e.target.files;
        this.fileToUpload = files.item(0);
        const options = {
            file: this.fileToUpload,
            fileName: this.fileName || this.fileToUpload.name,
            useUniqueFileName: this.useUniqueFileName,
            tags: this.tags,
            folder: this.folder,
            customMetadata: this.customMetadata,
            isPrivateFile: this.isPrivateFile,
            overwriteFile: this.overwriteFile,
            overwriteAITags: this.overwriteAITags,
            overwriteTags: this.overwriteTags,
            overwriteCustomMetadata: this.overwriteCustomMetadata,
            customCoordinates: this.customCoordinates,
            responseFields: this.responseFields,
            extensions: this.extensions,
            webhookUrl: this.webhookUrl,
            onError: this.onError,
            onSuccess: this.onSuccess,
            transformation: this.transformation,
        };
        // Custom validation
        if (!this.checkCustomFileValidation(options.file)) {
            return;
        }
        if (!this.checkAuthenticator(options)) {
            return;
        }
        this.startIkUpload(e, options);
    }
    checkCustomFileValidation(file) {
        if (this.validateFile && typeof this.validateFile === 'function') {
            return this.validateFile(file);
        }
        return true;
    }
    checkAuthenticator(options) {
        if (!this.authenticator || typeof this.authenticator !== "function" || this.authenticator.length !== 0 || !(this.authenticator() instanceof Promise)) {
            return this.throwError("The authenticator function is not provided or is not a function.", options);
        }
        return true;
    }
    throwError(message, options) {
        if (options && options.onError instanceof EventEmitter) {
            options.onError.emit({
                message: message || "Something went wrong.",
            });
        }
        return false;
    }
    startIkUpload(e, options) {
        // Custom upload-start tracker
        if (this.onUploadStart && typeof this.onUploadStart === 'function') {
            this.onUploadStart(e);
        }
        // Custom upload-progress tracker
        options.xhr = new XMLHttpRequest();
        this.xhr = options.xhr;
        const params = this.getUploadParams(options);
        const progressCb = this.createUploadProgressMonitor(options.xhr);
        const ik = this.getIkInstance();
        const authPromise = this.authenticator();
        authPromise.then((obj) => this.handleAuthResponse(obj, ik, params, options, progressCb)).catch((data) => {
            var error;
            if (data instanceof Array) {
                error = data[0];
            }
            else {
                error = data;
            }
            this.throwError(String(error), options);
        });
    }
    getIkInstance() {
        if (this.publicKey === undefined ||
            this.urlEndpoint === undefined) {
            return this.imagekit.ikInstance;
        }
        return new ImagekitService({
            urlEndpoint: this.urlEndpoint,
            publicKey: this.publicKey,
        })._ikInstance;
    }
    handleUploadResponse(err, result, options, progressCb) {
        if (err) {
            this.throwError(err, options);
        }
        else {
            if (options.onSuccess instanceof EventEmitter) {
                options.onSuccess.emit(result);
            }
            if (options.xhr)
                options.xhr.upload.removeEventListener('progress', progressCb);
        }
    }
    createUploadProgressMonitor(xhr) {
        const progressCb = (e) => {
            if (this.onUploadProgress && typeof this.onUploadProgress === 'function') {
                // Custom upload-progress tracker
                this.onUploadProgress(e);
            }
        };
        if (xhr)
            xhr.upload.addEventListener('progress', progressCb);
        return progressCb;
    }
    getUploadParams(options) {
        const params = {
            file: options.file,
            fileName: options.fileName
        };
        if (options.useUniqueFileName !== undefined) {
            Object.assign(params, { useUniqueFileName: options.useUniqueFileName });
        }
        if (options.folder !== undefined) {
            Object.assign(params, { folder: options.folder });
        }
        if (options.customMetadata !== undefined) {
            Object.assign(params, { customMetadata: options.customMetadata });
        }
        if (options.webhookUrl !== undefined) {
            Object.assign(params, { webhookUrl: options.webhookUrl });
        }
        if (options.isPrivateFile !== undefined) {
            Object.assign(params, { isPrivateFile: options.isPrivateFile });
        }
        if (options.overwriteFile !== undefined) {
            Object.assign(params, { overwriteFile: options.overwriteFile });
        }
        if (options.overwriteAITags !== undefined) {
            Object.assign(params, { overwriteAITags: options.overwriteAITags });
        }
        if (options.overwriteTags !== undefined) {
            Object.assign(params, { overwriteTags: options.overwriteTags });
        }
        if (options.overwriteCustomMetadata !== undefined) {
            Object.assign(params, { overwriteCustomMetadata: options.overwriteCustomMetadata });
        }
        if (options.tags !== undefined) {
            Object.assign(params, { tags: options.tags });
        }
        if (options.customCoordinates !== undefined) {
            Object.assign(params, { customCoordinates: options.customCoordinates });
        }
        if (options.responseFields !== undefined) {
            Object.assign(params, { responseFields: options.responseFields });
        }
        if (options.extensions !== undefined) {
            Object.assign(params, { extensions: options.extensions });
        }
        if (options.xhr !== undefined) {
            Object.assign(params, { xhr: options.xhr });
        }
        if (options.transformation !== undefined) {
            Object.assign(params, { transformation: options.transformation });
        }
        return params;
    }
}
IkUploadComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IkUploadComponent, deps: [{ token: i0.ElementRef }, { token: ImagekitService }], target: i0.ɵɵFactoryTarget.Component });
IkUploadComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IkUploadComponent, selector: "ik-upload", inputs: { fileName: "fileName", useUniqueFileName: "useUniqueFileName", tags: "tags", folder: "folder", publicKey: "publicKey", urlEndpoint: "urlEndpoint", authenticator: "authenticator", isPrivateFile: "isPrivateFile", overwriteFile: "overwriteFile", overwriteAITags: "overwriteAITags", overwriteTags: "overwriteTags", overwriteCustomMetadata: "overwriteCustomMetadata", customCoordinates: "customCoordinates", webhookUrl: "webhookUrl", responseFields: "responseFields", extensions: "extensions", customMetadata: "customMetadata", buttonRef: "buttonRef", validateFile: "validateFile", onUploadStart: "onUploadStart", onUploadProgress: "onUploadProgress", transformation: "transformation" }, outputs: { onError: "onError", onSuccess: "onSuccess" }, providers: [ImagekitService], ngImport: i0, template: `
  <input *ngIf="buttonRef; else elseBlock" type="file" (change)="handleFileInput($event)" style="display:none"/>
  <ng-template #elseBlock>
    <input type="file" (change)="handleFileInput($event)" />
  </ng-template>
  `, isInline: true, directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IkUploadComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ik-upload',
                    template: `
  <input *ngIf="buttonRef; else elseBlock" type="file" (change)="handleFileInput($event)" style="display:none"/>
  <ng-template #elseBlock>
    <input type="file" (change)="handleFileInput($event)" />
  </ng-template>
  `,
                    providers: [ImagekitService]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: ImagekitService }]; }, propDecorators: { fileName: [{
                type: Input,
                args: ['fileName']
            }], useUniqueFileName: [{
                type: Input,
                args: ['useUniqueFileName']
            }], tags: [{
                type: Input,
                args: ['tags']
            }], folder: [{
                type: Input,
                args: ['folder']
            }], publicKey: [{
                type: Input,
                args: ['publicKey']
            }], urlEndpoint: [{
                type: Input,
                args: ['urlEndpoint']
            }], authenticator: [{
                type: Input,
                args: ["authenticator"]
            }], isPrivateFile: [{
                type: Input,
                args: ['isPrivateFile']
            }], overwriteFile: [{
                type: Input,
                args: ['overwriteFile']
            }], overwriteAITags: [{
                type: Input,
                args: ['overwriteAITags']
            }], overwriteTags: [{
                type: Input,
                args: ['overwriteTags']
            }], overwriteCustomMetadata: [{
                type: Input,
                args: ['overwriteCustomMetadata']
            }], customCoordinates: [{
                type: Input,
                args: ['customCoordinates']
            }], webhookUrl: [{
                type: Input,
                args: ['webhookUrl']
            }], responseFields: [{
                type: Input,
                args: ['responseFields']
            }], extensions: [{
                type: Input,
                args: ['extensions']
            }], customMetadata: [{
                type: Input,
                args: ['customMetadata']
            }], buttonRef: [{
                type: Input,
                args: ['buttonRef']
            }], onError: [{
                type: Output
            }], onSuccess: [{
                type: Output
            }], validateFile: [{
                type: Input,
                args: ['validateFile']
            }], onUploadStart: [{
                type: Input,
                args: ['onUploadStart']
            }], onUploadProgress: [{
                type: Input,
                args: ['onUploadProgress']
            }], transformation: [{
                type: Input,
                args: ['transformation']
            }] } });

class ImagekitioAngularModule {
    static forRoot(config) {
        return {
            ngModule: ImagekitioAngularModule,
            providers: [
                { provide: ImageKitConfiguration, useValue: config }
            ]
        };
    }
}
ImagekitioAngularModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ImagekitioAngularModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ImagekitioAngularModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ImagekitioAngularModule, declarations: [IkImageComponent,
        IkVideoComponent,
        IkUploadComponent], imports: [CommonModule], exports: [IkImageComponent,
        IkVideoComponent,
        IkUploadComponent] });
ImagekitioAngularModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ImagekitioAngularModule, providers: [ImagekitService], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ImagekitioAngularModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        IkImageComponent,
                        IkVideoComponent,
                        IkUploadComponent
                    ],
                    imports: [CommonModule],
                    exports: [
                        IkImageComponent,
                        IkVideoComponent,
                        IkUploadComponent
                    ],
                    providers: [ImagekitService]
                }]
        }] });

/*
 * Public API Surface of imagekitio-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { IkImageComponent, IkUploadComponent, IkVideoComponent, ImageKitConfiguration, ImagekitService, ImagekitioAngularModule };
//# sourceMappingURL=imagekitio-angular.js.map
